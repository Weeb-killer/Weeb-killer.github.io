<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>软件测试 | Weeb-killer的博客</title><meta name="author" content="Weeb-killer"><meta name="copyright" content="Weeb-killer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这几篇没做什么很大的修改，基本上按照上面给的重点而开始的 Validation &amp; Verification验证(verification)和确认(validation)  验证指保证软件正确的实现了某一特定功能的一系列活动； 我们的产品做得对吗? Are we building the product right  确认指的是保证软件的实现满足了用户需求的一系列活动； 我们在做正确的">
<meta property="og:type" content="article">
<meta property="og:title" content="软件测试">
<meta property="og:url" content="https://weeb-killer.github.io/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="Weeb-killer的博客">
<meta property="og:description" content="这几篇没做什么很大的修改，基本上按照上面给的重点而开始的 Validation &amp; Verification验证(verification)和确认(validation)  验证指保证软件正确的实现了某一特定功能的一系列活动； 我们的产品做得对吗? Are we building the product right  确认指的是保证软件的实现满足了用户需求的一系列活动； 我们在做正确的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weeb-killer.github.io/img/avatar.png">
<meta property="article:published_time" content="2024-01-11T08:06:09.000Z">
<meta property="article:modified_time" content="2024-01-11T08:12:01.687Z">
<meta property="article:author" content="Weeb-killer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://weeb-killer.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://weeb-killer.github.io/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件测试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-11 16:12:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/backg.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Weeb-killer的博客"><span class="site-name">Weeb-killer的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-11T08:06:09.000Z" title="发表于 2024-01-11 16:06:09">2024-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-11T08:12:01.687Z" title="更新于 2024-01-11 16:12:01">2024-01-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件测试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><img src="IMG_0251.JPG" alt="IMG_0251" style="zoom: 33%;" />

<p>这几篇没做什么很大的修改，基本上按照上面给的重点而开始的</p>
<h1 id="Validation-Verification"><a href="#Validation-Verification" class="headerlink" title="Validation &amp; Verification"></a>Validation &amp; Verification</h1><p>验证(verification)和确认(validation)</p>
<ul>
<li><p>验证指保证软件<strong>正确的实现</strong>了某一特定功能的一系列活动； 我们的产品做得对吗? Are we building the product right</p>
</li>
<li><p>确认指的是保证软件的<strong>实现满足</strong>了用户需求的一系列活动； 我们在做正确的产品吗? Are we building the right product</p>
</li>
</ul>
<h1 id="Psychological-Economical-Factors"><a href="#Psychological-Economical-Factors" class="headerlink" title="Psychological &amp; Economical Factors"></a>Psychological &amp; Economical Factors</h1><p>page 4-7</p>
<p><strong>软件测试原则</strong></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231220150843691.png" alt="image-20231220150843691"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231220150852932.png" alt="image-20231220150852932"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104160111791.png" alt="image-20240104160111791"></p>
<h2 id="心理学上的因素-Psychological"><a href="#心理学上的因素-Psychological" class="headerlink" title="心理学上的因素 Psychological"></a>心理学上的因素 Psychological</h2><p><strong>Testing is the process of executing a program with the intent of finding errors</strong></p>
<p><strong>测试是为发现错误而执行程序的过程</strong></p>
<p>测试提高了程序的可靠性和质量</p>
<p>人总是会倾向于选择可能较少导致程序出错的测试数据</p>
<p>成功的测试指 这个测试是有效的 找出的错误可修复 或无错误</p>
<p>而不成功是指没能适当地对程序进行检查。</p>
<p>有时未能找出错误的测试就是不成功的测试</p>
<h2 id="经济学上的因素-Economical"><a href="#经济学上的因素-Economical" class="headerlink" title="经济学上的因素 Economical"></a>经济学上的因素 Economical</h2><p>软测不可能找出一个程序中全部的问题 即使是很小的程序</p>
<p>一般而言测试用例的数量和发现问题的数量成正比</p>
<p>这样就反映（暗示）出软测的经济学上的挑战</p>
<p>而应对这个挑战 则有两种测试方法：黑盒和白盒</p>
<h1 id="Black-box-White-box-Testing"><a href="#Black-box-White-box-Testing" class="headerlink" title="Black-box &amp; White-box Testing"></a>Black-box &amp; White-box Testing</h1><p>page7-10</p>
<h2 id="测试用例part"><a href="#测试用例part" class="headerlink" title="测试用例part"></a>测试用例part</h2><p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214195552891.png" alt="image-20231214195552891"></p>
<p>由于时间和成本的约束，关键问题是：</p>
<p><strong>在所有可能的测试用例中，哪个子集最有可能发现最多的错误</strong></p>
<p>效率最低的是随机输入测试，也就是在所有可能的输入值中随机选择某个子集对程序进行测试的过程</p>
<p>推荐是使用黑盒测试方法来设计测试用例，然后视情况需要使用白盒测试方法来设计补充的测试用例</p>
<h2 id="Black-box"><a href="#Black-box" class="headerlink" title="Black-box"></a><u>Black-box</u></h2><p>是<strong>数据驱动</strong>(data-driven)的测试或者说是<strong>输入&#x2F;输出驱动</strong>的测试</p>
<p>将程序视为一个黑盒子</p>
<p><strong>测试目标</strong>与<strong>程序的内部机制和机构</strong>无关，将重点放在发现程序不按其规范正确运行的环境条件</p>
<p>测试数据完全来自软件规范 也就是不需要了解程序内部结构</p>
<p>使用这个测试方法来发现全部错误，则判断的标准就是’’穷举输入测试’’将一切有<u>可能</u>的输入**(不是有效)**都测试一遍</p>
<p>如果有数据库的话就更麻烦了 还要测试所有可能的事务顺序</p>
<p>从经济学上而言，穷举测试不大可能，<strong>测试投入的目标在于通过优先的测试用例，最大限度地提高找到问题的数量</strong>，因此还需要知道软件内部的内容</p>
<h3 id="测试用例BB"><a href="#测试用例BB" class="headerlink" title="测试用例BB"></a>测试用例BB</h3><p>基于程序规划说明书的黑盒测试的目标是找到程序不符合规格说明书的地方</p>
<ul>
<li><strong><u>等价划分</u></strong></li>
</ul>
<p>前面提到穷举输入测试的时候，我们想要找到测试用例的其中一个子集，这个子集正确且可以找到最多错误</p>
<p>首先要控制测试用例的增加，然后还有尽可能覆盖大多数其他可能的测试用例</p>
<p>每个测试用例必须尽可能多的体现不同的输入情况，最大限度的减少测试所需要的数量。</p>
<p>尽量将程序的输入范围进行划分，将他们分拆成有限数量的<strong>等价类</strong></p>
<p>意思就是<u><strong>测试每个等价类的代表性数据就等同于测试该类其他的任何数据</strong></u></p>
<p>两个步骤：*<u>确定等价类</u>*	<em><u>生成测试用例</u></em></p>
<ol>
<li>确定等价类</li>
</ol>
<img src="image-20231218153920168.png" alt="image-20231218153920168" style="zoom:67%;" />

<p>选取一个输入条件（规格说明的一个句子或者一个短语）外部条件</p>
<p>有效等价类表示程序的有效输入 而无效等价类是其他任何可能的输入条件也就是不正确的输入值</p>
<img src="image-20231218154244670.png" alt="image-20231218154244670" style="zoom:67%;" />

<p>你要是发现程序并未等同地处理等价类中的元素，那么就把这个等价类再分成小一些的等价类</p>
<p>例子如上</p>
<ol start="2">
<li>生成测试用例</li>
</ol>
<p>执行步骤</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218154508350.png" alt="image-20231218154508350"></p>
<p>为啥要针对无效等价类，让他一个用例覆盖一个无效等价类呢</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104184230695.png" alt="image-20240104184230695"></p>
<p><u><em><strong>边界值分析</strong></em></u></p>
<p>相比没有使用这个的测试用例，使用了可以有更高的测试回报率</p>
<p>上面那些等价类就是边界条件</p>
<p>那么久设定几个测试用例在<strong>边界值内（一点点）</strong> <strong>刚好压线</strong> 和刚好<strong>超线（一点点）</strong></p>
<p>和前者的不同</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104184516629.png" alt="image-20240104184516629"></p>
<p>不仅要在输入的方面考虑，输出也要考虑到</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104184949979.png" alt="image-20240104184949979"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104184940950.png" alt="image-20240104184940950"></p>
<p>二者相比，边界值分析考察正处于等价划分边界或在边界附近的状态</p>
<p><del><u>因果图</u></del>（不考）</p>
<p><u><em><strong>错误猜测</strong></em></u></p>
<p>就是靠“猜” 很难归纳</p>
<p>依赖直觉的非正规过程</p>
<p><strong><u><em>测试策略</em></u></strong></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218155252054.png" alt="image-20231218155252054"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218155302178.png" alt="image-20231218155302178"></p>
<h2 id="White-box"><a href="#White-box" class="headerlink" title="White-box"></a>White-box</h2><p>是<strong>逻辑驱动</strong>(logic-driven)的测试，允许我们查看程序内部结构，<u>对程序逻辑结构进行检查</u>，而从中获取测试数据 （常常忽略程序的规范）</p>
<p><u>将程序中的每条语句至少执行一次</u> 人称：穷举路径测试(exhaustive path testing)</p>
<p>意思就是如果测试用例执行了程序中所有可能的控制流路径，那么程序可能得到了完全测试，而这样就太多测试用例了 即使这样仍然程序可能会出现错误原因如下</p>
<ul>
<li>穷举路径测试不能保证程序符合其设计规范</li>
</ul>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231213194748582.png" alt="image-20231213194748582"></p>
<ul>
<li>程序可能会因为缺少某些路径而存在问题 而这个方法不能找出缺少了哪些必须路径</li>
<li>这个方法不一定会暴露出数据敏感错误</li>
</ul>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231213195139044.png" alt="image-20231213195139044"></p>
<p>虽然穷举输入测试要比这个方法强一些，但都不是有效的方法</p>
<h3 id="测试用例WB"><a href="#测试用例WB" class="headerlink" title="测试用例WB"></a>测试用例WB</h3><p><strong><u>逻辑覆盖测试</u></strong></p>
<p>对于语句覆盖，也就是每个语句至少执行一次</p>
<p>每行都跑到，但是对于if语句中的”与“或者“或”,有些内容跑不到</p>
<p>比如说要是两个条件都是正确的，那么你写“与”和”或“的结果就是一样的，但是你这个测试并没有找出这个问题</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104170724016.png" alt="image-20240104170724016"></p>
<p><strong>要求程序中所有判断都至少覆盖一次，同时每一条语句或者入口点都被执行一次</strong></p>
<p>以下都是逻辑覆盖的方法</p>
<ul>
<li><strong><u>语句覆盖</u></strong></li>
</ul>
<p>程序中的全部语句都跑过 每个语句至少执行一次</p>
<ul>
<li><strong><u>判定覆盖或分支覆盖</u></strong></li>
</ul>
<p>较强的逻辑覆盖准则</p>
<p>比语句覆盖更强一点</p>
<p><strong>每个判断都至少有一个真和假的输出结果,也就是每条分支路径都要遍历一次</strong></p>
<p><strong>每个判定的所有可能结果至少出现一次</strong></p>
<p>一般可以满足语句覆盖 但仍然有例外：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214200546219.png" alt="image-20231214200546219"></p>
<p>由于将语句覆盖视为一个必要条件，所以说我们希望判定覆盖或分支覆盖理应涵盖语句覆盖，也就是每个判断必须要有T和F，并且每条语句至少执行一次，每个入口点（包括ON单元）都必须至少被调用一次</p>
<ul>
<li><strong><u>条件覆盖</u></strong></li>
</ul>
<img src="image-20240104171812907.png" alt="image-20240104171812907" style="zoom:67%;" />



<p>比判定覆盖更强一些</p>
<p><strong>保证将一个判断中的每个条件的所有可能结果至少执行一次</strong>，补充上对程序或子程序，包括ON单元的每一个入口点都至少调用一次</p>
<p>和判定覆盖一样不一定每条语句都执行到 使得其中<strong>每个条件</strong>都有true false的结果</p>
<p>例子：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231215162644306.png" alt="image-20231215162644306"></p>
<p>而对于判定覆盖则是每个判定都有true false的结果 而条件覆盖则会更细一点</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104181927312.png" alt="image-20240104181927312"></p>
<p>虽说这个例子中条件和判断覆盖生成的测试用例数量是一样的</p>
<p><u><em>虽说条件覆盖要比判定覆盖要更强一些 但注意条件覆盖不一定涵盖了判断覆盖</em></u></p>
<p>例子：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231215163514250.png" alt="image-20231215163514250"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231215162644306.png" alt="image-20231215162644306"></p>
<p>对于上面这个例子，使用判定覆盖的话，会将循环从K&#x3D;0执行到K&#x3D;51就可以满足准则，没有考虑后面的while语句为假的情况，而条件的话就要考虑J+K&lt;Quest产生一个为假的结果</p>
<p><strong>A B一真一假虽然满足了条件覆盖 但是这整个与的结果仍然是false</strong></p>
<img src="image-20240104171812907.png" alt="image-20240104171812907" style="zoom:67%;" />

<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104182703021.png" alt="image-20240104182703021"></p>
<p>这两个测试用例只包含了abe路径，四个判定结果的两个 （条件的话是FTFT, TFTF）(F,T)</p>
<p>为了解决上面的问题你二者都考虑就行了</p>
<p>所以采用<strong>判定&#x2F;条件覆盖</strong>：每个条件的所有可能结果至少执行一次，将每个判断的所有可能结果至少执行一次，将每个入口点都至少调用一次</p>
<p>有时候还是不行 比如说逻辑与&amp;&amp;</p>
<p>当前面一个条件是错误时 后面的条件不会执行</p>
<ul>
<li><strong><u>多重条件覆盖</u></strong></li>
</ul>
<p>这个可以部分解决这个问题</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104183129272.png" alt="image-20240104183129272"></p>
<p>要求是<strong>将每个判定中的所有可能的条件结果的组合，以及所有入口都至少执行一次</strong></p>
<p>满足多重条件覆盖准则的测试用例集会同时满足 条件 判定 以及判定条件</p>
<h1 id="Inspection-Walkthrough-Review-Desk-checking-Peer-rating"><a href="#Inspection-Walkthrough-Review-Desk-checking-Peer-rating" class="headerlink" title="Inspection, Walkthrough, Review (Desk checking; Peer rating)"></a>Inspection, Walkthrough, Review (Desk checking; Peer rating)</h1><p>page15	(28)</p>
<p>影响人工测试的原因</p>
<ul>
<li>应用程序的大小和其的复杂度</li>
<li>开发团队的大小</li>
<li>应用开发的时间安排</li>
<li>程序开发团队的背景和文化</li>
</ul>
<p>优势</p>
<p>让作者以外的人参与进来(相对于检查办公桌)</p>
<p>更精确地定位bug(相对于黑盒测试)</p>
<p>善于验证，能发现30-70%的逻辑设计和编码错误</p>
<p>缺点</p>
<p>不擅长验证或发现高级设计错误</p>
<p>只擅长发现某些类型的错误，作为基于计算机的测试的补充(例如，非初始变量vs除以零)</p>
<p>•Advantages</p>
<p>1.Involve people other than the author (vs desk-checking)</p>
<p>2.Locate bugs more precisely (vs black-box testing)</p>
<p>3.Good at verification, can find 30-70% logic design and coding errors</p>
<p>•Disadvantages</p>
<p>1.Bad at validation or finding high-level design errors</p>
<p>2.Only good at finding certain types of errors, complementary to computer-based testing (e.g. uninitiated variables vs division by zero)</p>
<h2 id="Inspection-Walkthrough"><a href="#Inspection-Walkthrough" class="headerlink" title="Inspection &amp; Walkthrough"></a>Inspection &amp; Walkthrough</h2><p>都要求人们组成小组 一起开会找问题而不一定要解决</p>
<p>这是对过去桌面检查Desk checking的改进</p>
<p>30%-70%的逻辑设计和编码错误，不代表所有错误中多达70%可能会被找出来，而是这些方法在测试结束时可以有效地查找出多达70%的已知错误。因为错误的总数是始终未知的。</p>
<p>相比那些基于计算机的测试方法，人工方法比基于计算机的方法更加有效，在某些特定类型的错误</p>
<p>不让代码的作者来 让别人来</p>
<p>一旦发现错误可以精确定位 降低调式(错误修改)的成本 且能成批发现错误 </p>
<p>但是不能有效地查找出<strong>高层次</strong>的设计错误 比如说在<strong>软件需求分析阶段</strong>的错误</p>
<h3 id="WalkThrough"><a href="#WalkThrough" class="headerlink" title="WalkThrough"></a>WalkThrough</h3><p>也是以小组开展</p>
<p>人员：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214194450374.png" alt="image-20231214194450374"></p>
<p>有人会带测试用例来 <strong><u>然后测试用例在人脑中进行推演</u></strong></p>
<p>程序的状态会被记录在纸上</p>
<p>把测试数据顺着程序的<strong>逻辑结构</strong>走一遍</p>
<p>数据用例需要少且简单</p>
<h2 id="Inspection"><a href="#Inspection" class="headerlink" title="Inspection"></a>Inspection</h2><p> 代码检查多以组为单位阅读代码，是一系列规程和错误检查技术的集合。集中于<strong>规程</strong>和<strong>要填写的表格</strong></p>
<p>相比walkthrough它没有测试用例</p>
<p>4人组成 1人发挥协调作用，这个人不是程序的编码人员 但了解程序的细节</p>
<p>职责：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214193954743.png" alt="image-20231214193954743"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214194003138.png" alt="image-20231214194003138"></p>
<p>并且代码的作者需要位列其中，一名该程序的非编码人员和一个测试人员</p>
<p>流程</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214194148554.png" alt="image-20231214194148554"></p>
<p>改bug在检查会议后</p>
<p>常见错误:</p>
<ul>
<li>数据引用错误</li>
<li>数据声明错误</li>
<li>运算错误</li>
<li>比较错误</li>
<li>控制流程错误</li>
<li>接口错误</li>
<li>输入输出错误</li>
</ul>
<h2 id="Desk-checking桌面检查"><a href="#Desk-checking桌面检查" class="headerlink" title="Desk checking桌面检查"></a>Desk checking桌面检查</h2><p>大概就是自己对自己的程序推演一遍</p>
<p>一个人阅读程序，一个人对照错误列表检查程序，一个人对程序推演测试数据</p>
<p>这个一个人可以是别人，你可以和别人换程序进行桌面检查，但还是效果比较差</p>
<p>因为对于之前两个，它们是有小组，小组内部存在相互促进的效应</p>
<h2 id="Peer-rating同行评审"><a href="#Peer-rating同行评审" class="headerlink" title="Peer rating同行评审"></a>Peer rating同行评审</h2><p>不是为了测试程序</p>
<p>这是为了</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214195236650.png" alt="image-20231214195236650"></p>
<p><strong>提供自我评价的手段</strong></p>
<p>选一个人当评审过程的管理员，让他挑人，这些人选自己写的最能展现自己能力的程序和一个自己写的质量比较差的</p>
<p>然后打分按照下面的问题 再提出评价和改进的建议</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231214195400907.png" alt="image-20231214195400907"></p>
<p>结束后参与者会收到自己的两个程序的匿名评价表和一个带统计的总结</p>
<h1 id="Integration-Testing-Nonincremenatal-Incremental-Top-down-Bottom-up-Driver-Module-Stub-Module-Regression-Testing"><a href="#Integration-Testing-Nonincremenatal-Incremental-Top-down-Bottom-up-Driver-Module-Stub-Module-Regression-Testing" class="headerlink" title="Integration Testing (Nonincremenatal; Incremental; Top-down;Bottom-up; Driver Module; Stub Module), Regression Testing"></a>Integration Testing (Nonincremenatal; Incremental; Top-down;Bottom-up; Driver Module; Stub Module), Regression Testing</h1><p>page 70 本章开始 page81 增量测试</p>
<p><em><strong>模块测试</strong></em></p>
<p>模块测试(module testing)是对程序中的单个子程序，子分支，子类，子过程进行测试的过程 而不是直接对一整个程序进行测试，而是一些小模块</p>
<p>目的是为了将模块的功能与定义模块的功能规格说明或接口规格说明进行比较</p>
<p>总体上**<u>面向白盒</u>**，要是对一个大一点的软件进行测试，比如说一个完整的程序，白盒测试不好展开，其次后续的测试过程着眼于发现其他类型的错误（也就是错误不一定与程序的逻辑有关了）</p>
<p><em><strong>测试用例设计</strong></em></p>
<p>需要<strong>模块规格说明</strong>和<strong>模块的源代码</strong> 规格说明规定了输入和输出参数以及模块的功能</p>
<p>使用<u>一种或者多种</u><strong>白盒测试方法</strong>分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例</p>
<h2 id="增量测试与非增量测试-Integration-Testing-Nonincremental"><a href="#增量测试与非增量测试-Integration-Testing-Nonincremental" class="headerlink" title="增量测试与非增量测试 Integration Testing&amp;Nonincremental"></a>增量测试与非增量测试 Integration Testing&amp;Nonincremental</h2><p>将模块组装成工作程序的方式</p>
<p><u><strong>非增量或崩溃测试(big-bang)：先独立地测试每一个模块 然后再组装成完整的程序</strong></u></p>
<p><u><strong>增量或集成测试：将下一步要测试的模块组装到测试完成的模块集合中，再进行测试</strong></u></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218161635137.png" alt="image-20231218161635137"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218161701799.png" alt="image-20231218161701799"></p>
<p>一般而言增量测试会好一点</p>
<h3 id="非增量测试"><a href="#非增量测试" class="headerlink" title="非增量测试"></a>非增量测试</h3><p>非增量：将6个玩意单独测试，将每一个模块看作一个独立实体，他们可以按次序或者同时进行测试，最后将他们组装或者集成为一个完整的程序</p>
<p>测试一个单独的模块需要一个<u><strong>驱动模块</strong></u>(driver module)和一个或者多个**<u>桩模块</u>**(stub module)</p>
<p>过程就是设计好测试用例后 将输入参数由驱动模块传递给模块B</p>
<p><u><strong>驱动模块：人为编写的小模块（现在可以使用测试工具代替），将测试用例驱动或传输到被测模块中，并且还向测试人员展示模块测试结果</strong></u></p>
<p>一般来讲我们的project里面就一个主函数入口，所以我们测试的模块不一定有这个入口（也就是让他直接运行的玩意），所以测试人员使用一个驱动模块让他单独运行</p>
<p><u><strong>桩模块:用于代替外部系统、服务或对象，提供假设和预测的行为结果和异常反馈数据。通过对受控制和固定的程序输入产生预定输出，测试人员可以使用桩来检查单个系统结构组件是否按照预期工作。</strong></u></p>
<p><u>桩模块用来模拟依赖模块的功能</u></p>
<p>正如5-7图所示，我们目前测试的模块B他需要模块E的支持，所以还需要一个额外的部件使得B调用E时接受B的控制指令，这就由桩模块来完成，模拟E的功能</p>
<h3 id="增量测试"><a href="#增量测试" class="headerlink" title="增量测试"></a>增量测试</h3><p>增量测试的方法有很多，有从程序顶部进行的也有从程序底部进行</p>
<p>将洗一个要测试的模块组装到前面已经测试过的模块集合中去</p>
<p><em>先从程序底部开始</em></p>
<p>首先测试ECF模块 他们都是每个分支中最底层的那个模块，他们的测试可以是并行也可以是串行，因为是测试这三个模块，所以要编写3个驱动模块，然后去测试BD模块，此时要把BE结合，DF结合到一起进行测试，再次编写2个驱动模块，然后持续这个过程直到测试完模块A</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218161635137.png" alt="image-20231218161635137"></p>
<p>相比非增量和增量，非增量所需的工作量要多一些，一上面的这个当作例子</p>
<p>非增量需要5个驱动模块（最顶上的不用驱动）和5个桩模块（一个模块开发一个桩模块，最顶层的不需要桩模块），自底向上要5个驱动模块，自顶向下是5个桩模块</p>
<h2 id="自顶向下测试和自底向上测试"><a href="#自顶向下测试和自底向上测试" class="headerlink" title="自顶向下测试和自底向上测试"></a>自顶向下测试和自底向上测试</h2><p>这两种测试都是增量测试	自顶向下的测试 和 自顶向下的开发是同义词	而自顶向下的设计就和他们是两码事了</p>
<p>二者的比较：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218190206063.png" alt="image-20231218190206063"></p>
<h3 id="自顶向下测试"><a href="#自顶向下测试" class="headerlink" title="自顶向下测试"></a>自顶向下测试</h3><p>从程序顶部进行或者从初始模块开始，开始后，挑选一个后续模块进行增量测试，这个挑选的方法不是定数，只要是后续模块的丛书模块（也就是调用它的模块）先通过了测试</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218181031044.png" alt="image-20231218181031044"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218181044805.png" alt="image-20231218181044805"></p>
<p>首先测试A模块，所以需要编写BCD的桩模块， 有时候测试用例不能从程序顶部输入，比如说输入的数据是从一个或者多个桩模块提交过来的 比如说A的测试用例可以是模块B所传的，D模块可以将输入数据打印出来</p>
<p>如果模块A仅会调用一次模块B，那么要提交多个测试用例给A的话可以编写多个桩模块B，每次都是使用不同版本的桩模块B，或者将测试数据放在外部文件，然后使用桩模块B进行读取再传给模块A。</p>
<p>当模块A测试完了可以使用真的模块代替其中一个桩模块</p>
<img src="image-20231218182027617.png" alt="image-20231218182027617" style="zoom:67%;" />

<p>如果可以并行测试则可以一个程序员测试AB 另外一个测试AC 还有一个测试AD</p>
<p>测试的顺序也是不为1的</p>
<p>以下就是可采纳的顺序</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218182250458.png" alt="image-20231218182250458"></p>
<p>如果有别的需求之类的那就另外说，当然也有推荐的一些建议：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218182350940.png" alt="image-20231218182350940"></p>
<p>对于第二个建议是因为桩模块不只是要作为输入测试数据的方法，同时也要将输入打印或者说显现出来，如果早点把这些I&#x2F;O的模块加进来那么就可以再桩模块中少写输出测试用例结果的代码</p>
<p><em><u>然而自顶向下测试是有缺点的</u></em></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218183152962.png" alt="image-20231218183152962"></p>
<p>比如说此时我们需要使用模块H代替桩模块H，但是测试用例输入是从J出发的，中间隔了那么多步，我们很难知道数据到H时是多少，并且也很难控制到H时的数据。</p>
<p>另一方面我们需要了解测试的模块H的输出结果，但是输出的模块是I，如果我们需要根据I的输出推算出模块H的真实输出也是很难</p>
<p>再说了，你设计的时候是从上往下设计的，你在设计下面的同时上面已经开始写码了（写完开始测试了），那么未来你在设计下面的时候，提出的一些比较好的对上面的改进，可是上面都编好了码并且测试也完成了，那么这些理想的改进就只能放弃了</p>
<h3 id="自底向上测试"><a href="#自底向上测试" class="headerlink" title="自底向上测试"></a>自底向上测试</h3><p>自顶向下的缺点就是自底向上的优点，反之亦然。</p>
<p>一般从一些终端模块开始，也就是一个模块他不再调用别的模块，测试完后可以随意选择一个，当然也要满足要求，就是这个选择的模块他所调用的模块都已经测试过了</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218181031044.png" alt="image-20231218181031044"></p>
<p>第一步是测试 EJGKLI中的部分或者全部，可串行也可并行。此时每一个模块都需要一个驱动模块其中包含有效的测试输入、并且显示出测试的输出。不同于桩模块，驱动模块可以自己交迭调用测试模块，所以不用像自顶向下那样开发多个模块，并且一般而言驱动模块更好开发</p>
<p>他的问题也很明显，直到测试完成之前，这些模块都是一些小碎片，他们都是不能工作的</p>
<h2 id="回归测试Regression-Testing"><a href="#回归测试Regression-Testing" class="headerlink" title="回归测试Regression Testing"></a>回归测试Regression Testing</h2><p>对程序或者功能进行改进修改后进行回归测试，目的是判断程序的改动是否引起了其他地方的退步</p>
<p>回归测试是指修改了源代码后，<strong>重新测试以确认修改有没有引入新的错误或导致其他代码产生错误</strong></p>
<p>所以说你之前测试后的测试用例不应该丢掉，不然这里你又要重新设计测试用例了</p>
<h1 id="System-Testing-Function-Testing-Installation-Testing-Test-Completion"><a href="#System-Testing-Function-Testing-Installation-Testing-Test-Completion" class="headerlink" title="System Testing; Function Testing; Installation Testing; Test Completion"></a>System Testing; Function Testing; Installation Testing; Test Completion</h1><p>page 93本章开始</p>
<p>错误定义：当程序无法实现其最终用户要求的合理功能时，就发生了一个软件错误</p>
<p>外部规格说明：将上面两层内容转换成一个准确的产品规格说明，将产品看作一个黑盒，仅考虑其接口以及与最终用户的交互</p>
<img src="image-20231218190552431.png" alt="image-20231218190552431" style="zoom: 50%;" />

<img src="image-20231218190609422.png" alt="image-20231218190609422" style="zoom:67%;" />

<img src="image-20231218190625071.png" alt="image-20231218190625071" style="zoom:67%;" />

<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218190727107.png" alt="image-20231218190727107"></p>
<p>在其过程中为了防止出现错误，我们再每一步加上一个验证的过程</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218190854128.png" alt="image-20231218190854128"></p>
<p>在此过程中会有测试（测试≠验证）</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218191159121.png" alt="image-20231218191159121"></p>
<p>**<u>模块测试</u>**：是为了发现程序模块与其接口规格说明之间的不一致</p>
<p>**<u>功能测试</u>**：是为了证明程序未能符合其外部规格说明 Verif</p>
<p>**<u>系统测试</u>**：是为了证明软件产品与其初始目标不一致 Valid</p>
<h2 id="功能测试-Function-Testing"><a href="#功能测试-Function-Testing" class="headerlink" title="功能测试 Function Testing"></a>功能测试 Function Testing</h2><p>定义如上 <u>是为了证明程序未能符合其外部规格说明</u></p>
<p>外部规格说明是从最终用户的角度对程序行为的精确描述</p>
<p>一般而言功能测试是一个黑盒操作 <em><u><strong>要依赖早期的模块测试的过程来实现理想的白盒覆盖准则</strong></u></em></p>
<p>测试用例通过对规格说明进行分析而获取的，黑盒测试用例获取的那几个方法都适用于功能测试</p>
<p>意思就是不仅要测试是否有这个功能，而且还有测试这个功能做的符不符合我对它的水平要求</p>
<h2 id="系统测试-System-Testing"><a href="#系统测试-System-Testing" class="headerlink" title="系统测试 System Testing"></a>系统测试 System Testing</h2><p>他和功能测试是不一样的，他是将系统或者程序与其初始目标进行比较。</p>
<p>相比功能测试，它更加模糊，他是更早进行的一项测试</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218192805313.png" alt="image-20231218192805313"></p>
<p>并且还要注意在设计外部规格说明过程中所犯的转换错误，所以测试用例不能基于外部规格说明和目标文档来生成测试用例，因为不包含对程序外部接口的准确描述</p>
<p><em>所以会使用程序的用户文档或者书面材料，分析目标文档设计系统测试，分析用户文档来阐明测试用例</em></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218193511830.png" alt="image-20231218193511830"></p>
<p>测试用例的分类</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218193804957.png" alt="image-20231218193804957"></p>
<p>其中只讲安装测试</p>
<h2 id="安装测试-Installation-Testing"><a href="#安装测试-Installation-Testing" class="headerlink" title="安装测试 Installation Testing"></a>安装测试 Installation Testing</h2><p>在上面图片有：确保能够在所有支持的平台上安装软件</p>
<p>与设计过程没关系</p>
<p>它不是为了发现软件中的错误，而是发现安装过程中出现的错误</p>
<p>安装时会有这些事件发生</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218194338131.png" alt="image-20231218194338131"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218194518472.png" alt="image-20231218194518472"></p>
<h2 id="测试结束准则-Test-Completion"><a href="#测试结束准则-Test-Completion" class="headerlink" title="测试结束准则 Test Completion"></a>测试结束准则 Test Completion</h2><p>何时终止测试</p>
<p>最常见的准则是</p>
<ol>
<li>安排的测试时间用完了</li>
<li>执行完所有的测试用例还未发现错误，就结束了，也就是测试用例都不成功</li>
</ol>
<p>都是无效的</p>
<p>给第二条准则加上一些定语</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218195013350.png" alt="image-20231218195013350"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218195028651.png" alt="image-20231218195028651"></p>
<p>但是这样仍然是有缺陷的</p>
<p>或者用确切的数量来描述结束测试的条件</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104200236409.png" alt="image-20240104200236409"></p>
<p><strong>设定最后需要找到错误的数量，到数量才算结束</strong></p>
<p>这个数量需要是有意义的，所以需要做到这些</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231218195334319.png" alt="image-20231218195334319"></p>
<p>如何预测总数?</p>
<p>你可以测试一段时间，然后记录一下连续发现错误的间隔时间，然后把这些时间输入到一个公式的参数中。<u>你可以自己在一个模块中写点错误（这些都是不公开的），这个叫种子错误，然后给别人测试，看看一段时间后发现的种子错误和非种子错误的比例。</u>你也可以用行业内的平均值，像是编码结束时（做走查和检查之前），一般程序中的错误数量大致为每100行4-8个错误</p>
<p>你还可以靠现在的一些数据，比如，数据表明，在大型程序中，大约有40%的错误是编码和逻辑设计错误，剩下的错误则产生于早期的设计阶段</p>
<p>通过测试可以发现问题的百分比</p>
<p>估计源自特定设计过程的错误比例，以及在哪些测试阶段可能检测到这些错误。</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104202240529.png" alt="image-20240104202240529"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104202338537.png" alt="image-20240104202338537"></p>
<p>第三种方法就是需要我们在测试过程中记录每单位时间内发现的错误数量，然后通过检查统计曲线的形状，决定是要继续该阶段的测试，还是结束它开始下一测试阶段</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104202526129.png" alt="image-20240104202526129"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104202534240.png" alt="image-20240104202534240"></p>
<p>图一的话你就不能在第7周停下来因为现在是高峰，所以你现在要做的就是继续测试，你可以增加一些测试用例 如果是图二你就差不多可以结束功能测试开始系统测试了，当然也要考虑下降的原因，比如说测试用例用完了，或者缺少使用电脑的时间</p>
<p>最好的方法就是三者结合</p>
<p>模块测试的话，用第一个讲的方法就行（添加定语的那个）</p>
<h1 id="Usability-Testing-User-Recall-Hallway-Testing-Think-Aloud-Protocol-Remote-User-Testing-Eye-tracking-Number-of-Users-Questionnaire"><a href="#Usability-Testing-User-Recall-Hallway-Testing-Think-Aloud-Protocol-Remote-User-Testing-Eye-tracking-Number-of-Users-Questionnaire" class="headerlink" title="Usability Testing (User Recall; Hallway Testing; Think-Aloud Protocol; Remote User Testing; Eye-tracking; Number of Users; Questionnaire)"></a>Usability Testing (User Recall; Hallway Testing; Think-Aloud Protocol; Remote User Testing; Eye-tracking; Number of Users; Questionnaire)</h1><p>page116 本章开始</p>
<h5 id="可用性-用户体验-测试"><a href="#可用性-用户体验-测试" class="headerlink" title="可用性(用户体验)测试"></a>可用性(用户体验)测试</h5><p>在人的因素上研究和分析，是一个基于用户的软件测试,衡量有用性和易用性</p>
<p>首先先是可用性测试的基本要素</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231219184451068.png" alt="image-20231219184451068"></p>
<p>….</p>
<p>可用性或者说基于用户的测试基本上基于黑盒测试，不关心软件内部如何运作以及软甲内部设计结构。<strong>从功能缺陷到不符合人机工程学的设计失误来揭示软件设计存在的问题</strong></p>
<h5 id="测试用户的选择"><a href="#测试用户的选择" class="headerlink" title="测试用户的选择"></a>测试用户的选择</h5><p>完整的可用性测试草案需要<u>同一组</u>用户完成多个测试以及不同组用户完成多个测试</p>
<p>关注点是用户记忆</p>
<p>你的软件要是是针对于某一特定群体的话，你就要找一些专家进行测试了，他们要有一些这一类软件的实际使用经验</p>
<h3 id="用户记忆User-Recall"><a href="#用户记忆User-Recall" class="headerlink" title="用户记忆User Recall"></a>用户记忆User Recall</h3><p>测试用户在多次使用后再使用是否需要长时间去学习使用方法，下一次使用的时候用户还会不会了，会多少。看用户的学习成本</p>
<h3 id="需要多少用户进行测试-Number-of-User"><a href="#需要多少用户进行测试-Number-of-User" class="headerlink" title="需要多少用户进行测试 Number of User"></a>需要多少用户进行测试 Number of User</h3><p>当然人数越多，发现的问题也就越多</p>
<p>考虑到成本就不行了</p>
<p>基于一个公式，我们可以知道不需要那么多的人</p>
<p>这个地方使用<strong>L&#x3D;31%</strong> ，5个就能到达83%</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231219185913256.png" alt="image-20231219185913256"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104204029969.png" alt="image-20240104204029969"></p>
<h2 id="数据采集方法"><a href="#数据采集方法" class="headerlink" title="数据采集方法"></a>数据采集方法</h2><p>管理者和观察者可以通过很多方法获取数据</p>
<h3 id="发声思考-thinking-aloud"><a href="#发声思考-thinking-aloud" class="headerlink" title="发声思考 thinking-aloud"></a>发声思考 thinking-aloud</h3><p><strong>用户在执行测试的过程中表达出他们的想法和对软件的评价，测试参与者可以描述他们的任务，并说出自己对任务的理解和执行测试时其他任何想法</strong></p>
<p>开发者也可以事后找他们问问，前后两次的数据就可以提供非常有价值的反馈</p>
<p>但是这是有缺点的：</p>
<p>因为这个过程是全程录像并且当场有观察员接入，所以测试人员很难割舍这个“不自然”的环境因素而产生偏差。</p>
<h3 id="远程用户测试Remote-User-Testing"><a href="#远程用户测试Remote-User-Testing" class="headerlink" title="远程用户测试Remote User Testing"></a>远程用户测试Remote User Testing</h3><p>可以用第三方软件来记录每个击键和每个测试任务所花的时间</p>
<p>有一种解决方法就是把软件安装到用户的机子里去，这样就可以切割掉这个不自然的因素，但是就不能得到前者那种准确的反馈</p>
<h3 id="长廊测试或长廊拦截测试Hallway-testing"><a href="#长廊测试或长廊拦截测试Hallway-testing" class="headerlink" title="长廊测试或长廊拦截测试Hallway testing"></a>长廊测试或长廊拦截测试Hallway testing</h3><p>意思就是<strong>随机选择测试用户</strong>，就像从长廊随便抓一把人一样</p>
<h3 id="眼球追踪eye-tracking"><a href="#眼球追踪eye-tracking" class="headerlink" title="眼球追踪eye tracking"></a>眼球追踪eye tracking</h3><p><strong>数据是有关于观察者的目光在某个视觉元素上驻留的时间长短，反映观察者的思考程度</strong></p>
<p>这样可以知道最能吸引实验参与者的视觉元素、或者说按照什么顺序以及吸引时间的长短</p>
<p>用这样的数据开发者可以选择最有效的外观</p>
<h3 id="可用性调查问卷Usability-Questionnair"><a href="#可用性调查问卷Usability-Questionnair" class="headerlink" title="可用性调查问卷Usability Questionnair"></a>可用性调查问卷Usability Questionnair</h3><p>一些问卷的样例</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231219191408409.png" alt="image-20231219191408409"></p>
<p>可以把问题反过来问，用来测试用户是否明白问题的意思</p>
<h1 id="Debugging-Induction-Deduction-Backtracking-Testing"><a href="#Debugging-Induction-Deduction-Backtracking-Testing" class="headerlink" title="Debugging (Induction; Deduction; Backtracking;Testing)"></a>Debugging (Induction; Deduction; Backtracking;Testing)</h1><p>调试Debugging</p>
<p>page127 本章开始</p>
<p>调试为啥没人喜欢捏，原因如下：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231219192623879.png" alt="image-20231219192623879"></p>
<p>调试有两个步骤：<u>错误定位</u>和<u>错误修改</u></p>
<p><strong>暴力法调试</strong></p>
<p>最不需要动脑子的方法，但也是效率最低的方法</p>
<p>3种类型</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231219192808805.png" alt="image-20231219192808805"></p>
<p>为啥低效的原因也不提了</p>
<h2 id="归纳法调试Induction"><a href="#归纳法调试Induction" class="headerlink" title="归纳法调试Induction"></a>归纳法调试Induction</h2><p>认真思考一般肯定能解决问题，归纳就是其中一种，从细节到全局</p>
<p>步骤如下</p>
<p>1.确定相关数据</p>
<p>将所有可用数据或者症状考虑进去</p>
<p>列举出所有知道的程序执行的正确与不正确的地方</p>
<p>2.组织数据</p>
<p>按照表格所示去归纳数据</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231219193702799.png" alt="image-20231219193702799"></p>
<p>3.作出假设</p>
<p>错误的原因是啥，如果无法作出假设，那么就需要更多的数据，若有多个假设，那么选择最有可能的那个</p>
<p>4.证明假设</p>
<p>将假设与最初的线索或者数据相比较，确定假设可以完全解释他们</p>
<p>5.解决问题（还要回归测试）</p>
<h2 id="演绎法Deduction"><a href="#演绎法Deduction" class="headerlink" title="演绎法Deduction"></a>演绎法Deduction</h2><p>从普遍理论或前提出发，再排除和精炼，达到错误的位置</p>
<p>1.列举出所有可能的原因或者假设</p>
<p>2.使用数据排除可能的原因</p>
<p>要是所有原因都排了，那就增加数据用来增加新的假设，要是原因多了，那就选一个最有可能的。</p>
<p>3.提炼剩下的假设</p>
<p>原因可能正确，但可能不具体无法指出错误</p>
<p>4.证明剩下的假设</p>
<p>5.修复问题</p>
<h2 id="回溯法调试Backtracking"><a href="#回溯法调试Backtracking" class="headerlink" title="回溯法调试Backtracking"></a>回溯法调试Backtracking</h2><p>定位错误时可以<strong>沿着程序逻辑结构回溯不正确的结果，知道找到程序逻辑出错的地方</strong></p>
<p>保持想法，如果程序在这里是这样的，那么程序在上面位置的状态就必然是这样的</p>
<p>从程序错误的地方开始逆向执行程序</p>
<h2 id="测试法调试Testing"><a href="#测试法调试Testing" class="headerlink" title="测试法调试Testing"></a>测试法调试Testing</h2><p>“思维型”调试方法，使用测试用例来调试</p>
<p>测试用例分两种：一种是测试的测试用例，还有一种是调试的测试用例，目的是提供有用信息，供定位某个被怀疑的错误使用，用于调试的测试用例比较小，只需要覆盖一个或几个条件</p>
<p>可以和归纳，演绎法一起使用</p>
<h1 id="Agile-Extreme-Programming"><a href="#Agile-Extreme-Programming" class="headerlink" title="Agile &amp; Extreme Programming"></a>Agile &amp; Extreme Programming</h1><p>page142本章开始</p>
<p>敏捷开发下的测试</p>
<h2 id="敏捷开发-Agile"><a href="#敏捷开发-Agile" class="headerlink" title="敏捷开发 Agile"></a>敏捷开发 Agile</h2><p>轻量化，快速的开发方法</p>
<p>提倡迭代式和增量式开发，强调测试的重要</p>
<p>以用户为中心，客户需求为导向</p>
<p>价值观：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231219195821394.png" alt="image-20231219195821394"></p>
<p>敏捷开发是有很多方法的，没有一个单一固定的。但是他们都有三个共同点：</p>
<p><strong>依赖客户的参与、测试驱动以及紧凑的迭代开发周期</strong></p>
<p>几种开发方法：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231220100643330.png" alt="image-20231220100643330"></p>
<h3 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h3><p>需要每个人的参与，需要大量沟通以及协作工作，需要客户尽早参与到开发周期中</p>
<p>开发者从创建<strong>单元测试</strong>开始，这是失败验证测试，从破坏的角度设计测试用例。</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104210725572.png" alt="image-20240104210725572"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240104210734978.png" alt="image-20240104210734978"></p>
<p>一般使用自动化测试</p>
<p>测试人员不仅仅需要帮助开发者修复bug，而且还需要改变需求设计和其他一般性质量提升</p>
<h2 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h2><p>不仅需要客户参与，而且高度依赖模块的单元以及单元测试</p>
<p>先创建单元（模块）测试和验收测试，再开始创建代码库</p>
<p>XP的关注点：</p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20231220153643631.png" alt="image-20231220153643631"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240105013313119.png" alt="image-20240105013313119"></p>
<p><img src="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20240105013415241.png" alt="image-20240105013415241"></p>
<h1 id="Three-tier-model"><a href="#Three-tier-model" class="headerlink" title="Three-tier model"></a>Three-tier model</h1><p>page155 本章开始</p>
<p><strong>互联网应用</strong></p>
<p>这些一般都是C&#x2F;S模式，有些是B2C有些是B2B</p>
<h3 id="三层结构"><a href="#三层结构" class="headerlink" title="三层结构"></a>三层结构</h3><p><img src="/image-20231221161819527.png" alt="image-20231221161819527"></p>
<p>第一层，运行web网站，也就是”<strong>表示层</strong>“，因为该层将可视化了的内容提供给最终的用户 互联网应用的外观和感觉都来自这一层。GUI</p>
<p>第二层，运行应用服务器，“<strong>业务层</strong>”，运行的软件模拟业务流程。功能有：</p>
<ul>
<li>事务处理</li>
<li>用户身份确定</li>
<li>数据确认</li>
<li>程序日志</li>
</ul>
<p>第三层的核心是从数据源，一般是关系数据库管理系统中存储和获取数据，也就是“<strong>数据层</strong>”，与第二层进行通信的数据库设备。获取的数据可以从端用户来</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="/image-20231221162733087.png" alt="image-20231221162733087"></p>
<p>一些测试这三层的例子</p>
<p><img src="/image-20231221162850714.png" alt="image-20231221162850714"></p>
<h4 id="表示层测试"><a href="#表示层测试" class="headerlink" title="表示层测试"></a>表示层测试</h4><p>包括web站点的人机界面元素，要在会直接影响用户体验的特性中检查错误，还要确定信息的准确性，可以设计单元测试取查找页面中的结构问题，验证链接没错，文件没丢失</p>
<p>可以使用白盒测试</p>
<ol>
<li><strong>内容测试 content testing</strong></li>
</ol>
<p>包括整体审美、字体、色彩、拼写、内容准确性和默认值</p>
<p>   2.<strong>Web站点结构 Website architecture</strong></p>
<p>包括无效的链接或者图形</p>
<p>   3.<strong>用户环境 User environment</strong></p>
<p>包括web浏览器版本和操作系统配置</p>
<h4 id="业务层测试"><a href="#业务层测试" class="headerlink" title="业务层测试"></a>业务层测试</h4><p>对于第三方组件，最好使用黑盒测试技术为主要方法 内部开发的话使用白盒</p>
<p>三种特性可测试:</p>
<p><img src="/image-20231221164115882.png" alt="image-20231221164115882"></p>
<ul>
<li><strong>性能测试</strong></li>
</ul>
<p>性能不好的系统会使得用户怀疑其的鲁棒性，用户可能不会再次使用了，比如说界面加载缓慢，事务处理缓慢</p>
<p>保证性能规格说明需要完成，比如响应时间或者吞吐量</p>
<p>通常使用强度测试，就是给予大量的请求，检查系统是否可以接受，还可以检查顺便检查一下网络设施的鲁棒性和可测量性</p>
<ul>
<li><strong>数据验证</strong></li>
</ul>
<p>确保从用户那里收集来的数据是有效的。和测试单机系统时查找用户输入或者参数的错误类似，通过测试发现数据采集时的错误</p>
<ul>
<li><strong>事务测试</strong></li>
</ul>
<p>可视作业务层的系统测试，需要具备书面文档（也就是客户需求），详细定义事务的构成</p>
<p><img src="/image-20231221165730455.png" alt="image-20231221165730455"></p>
<h4 id="数据层测试"><a href="#数据层测试" class="headerlink" title="数据层测试"></a>数据层测试</h4><ul>
<li><strong>响应时间</strong>：需要量化结构化查询语言SQL语句的消耗时间</li>
</ul>
<p>确保网站能够即使响应用户请求和操作,响应时间不包括页面载入的时间，重点放在没有满足性能指标的数据库操作上，以防止有的数据库操作会阻塞其他操作。注意测试的仅仅是一项操作的响应时间，一般使用黑盒</p>
<ul>
<li><strong>数据完整性</strong>：验证数据储存适当而且正确</li>
</ul>
<p>与业务层的数据确认不同，业务层的是为了发下数据<strong>收集中</strong>的错误，而数据层则是发现<strong>存储中</strong>的错误，数据类型和长度可能会影响数据阶段和精确性</p>
<p>并且我们还要保证数据的同步更新，保持其最新</p>
<p>也就是数据信息<u>准确</u>且<u>最新</u></p>
<ul>
<li><strong>容错性和可恢复性</strong>：最大化MTBF(平均故障间隔)，最小化MTTR(平均故障恢复)</li>
</ul>
<p>测试数据库系统的容错性和可恢复性</p>
<p>MTBF取决于数据库的容错级别</p>
<p><img src="/image-20231221170904208.png" alt="image-20231221170904208"></p>
<p>可恢复性测试的目标就是设计出数据库无法恢复的场景出来，有时数据库崩溃，我们需要让它迅速恢复，开始于<strong>有效的备份</strong>，容错性好的往往是分布式的，一个坏了用另外一个备份的数据库</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Weeb-killer.github.io">Weeb-killer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://weeb-killer.github.io/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">https://weeb-killer.github.io/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Weeb-killer.github.io" target="_blank">Weeb-killer的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/" title="计算机网络-自顶向下"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络-自顶向下</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Weeb-killer</div><div class="author-info__description">眼光不错我的朋友</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Weeb-killer/Weeb-killer.github.io"><i class="fab fa-github"></i><span>Hello</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Weeb-killer/Weeb-killer.github.io" target="_blank" title=""><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">下一篇马上到来!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Validation-Verification"><span class="toc-number">1.</span> <span class="toc-text">Validation &amp; Verification</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Psychological-Economical-Factors"><span class="toc-number">2.</span> <span class="toc-text">Psychological &amp; Economical Factors</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%83%E7%90%86%E5%AD%A6%E4%B8%8A%E7%9A%84%E5%9B%A0%E7%B4%A0-Psychological"><span class="toc-number">2.1.</span> <span class="toc-text">心理学上的因素 Psychological</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B8%8A%E7%9A%84%E5%9B%A0%E7%B4%A0-Economical"><span class="toc-number">2.2.</span> <span class="toc-text">经济学上的因素 Economical</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Black-box-White-box-Testing"><span class="toc-number">3.</span> <span class="toc-text">Black-box &amp; White-box Testing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8Bpart"><span class="toc-number">3.1.</span> <span class="toc-text">测试用例part</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Black-box"><span class="toc-number">3.2.</span> <span class="toc-text">Black-box</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8BBB"><span class="toc-number">3.2.1.</span> <span class="toc-text">测试用例BB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#White-box"><span class="toc-number">3.3.</span> <span class="toc-text">White-box</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8BWB"><span class="toc-number">3.3.1.</span> <span class="toc-text">测试用例WB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Inspection-Walkthrough-Review-Desk-checking-Peer-rating"><span class="toc-number">4.</span> <span class="toc-text">Inspection, Walkthrough, Review (Desk checking; Peer rating)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspection-Walkthrough"><span class="toc-number">4.1.</span> <span class="toc-text">Inspection &amp; Walkthrough</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WalkThrough"><span class="toc-number">4.1.1.</span> <span class="toc-text">WalkThrough</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspection"><span class="toc-number">4.2.</span> <span class="toc-text">Inspection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Desk-checking%E6%A1%8C%E9%9D%A2%E6%A3%80%E6%9F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">Desk checking桌面检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Peer-rating%E5%90%8C%E8%A1%8C%E8%AF%84%E5%AE%A1"><span class="toc-number">4.4.</span> <span class="toc-text">Peer rating同行评审</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Integration-Testing-Nonincremenatal-Incremental-Top-down-Bottom-up-Driver-Module-Stub-Module-Regression-Testing"><span class="toc-number">5.</span> <span class="toc-text">Integration Testing (Nonincremenatal; Incremental; Top-down;Bottom-up; Driver Module; Stub Module), Regression Testing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%9D%9E%E5%A2%9E%E9%87%8F%E6%B5%8B%E8%AF%95-Integration-Testing-Nonincremental"><span class="toc-number">5.1.</span> <span class="toc-text">增量测试与非增量测试 Integration Testing&amp;Nonincremental</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%A2%9E%E9%87%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">非增量测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">增量测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B5%8B%E8%AF%95%E5%92%8C%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.</span> <span class="toc-text">自顶向下测试和自底向上测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">自顶向下测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">自底向上测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95Regression-Testing"><span class="toc-number">5.3.</span> <span class="toc-text">回归测试Regression Testing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#System-Testing-Function-Testing-Installation-Testing-Test-Completion"><span class="toc-number">6.</span> <span class="toc-text">System Testing; Function Testing; Installation Testing; Test Completion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95-Function-Testing"><span class="toc-number">6.1.</span> <span class="toc-text">功能测试 Function Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95-System-Testing"><span class="toc-number">6.2.</span> <span class="toc-text">系统测试 System Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95-Installation-Testing"><span class="toc-number">6.3.</span> <span class="toc-text">安装测试 Installation Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9D%9F%E5%87%86%E5%88%99-Test-Completion"><span class="toc-number">6.4.</span> <span class="toc-text">测试结束准则 Test Completion</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Usability-Testing-User-Recall-Hallway-Testing-Think-Aloud-Protocol-Remote-User-Testing-Eye-tracking-Number-of-Users-Questionnaire"><span class="toc-number">7.</span> <span class="toc-text">Usability Testing (User Recall; Hallway Testing; Think-Aloud Protocol; Remote User Testing; Eye-tracking; Number of Users; Questionnaire)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7-%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C-%E6%B5%8B%E8%AF%95"><span class="toc-number">7.0.0.0.1.</span> <span class="toc-text">可用性(用户体验)测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E6%88%B7%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">7.0.0.0.2.</span> <span class="toc-text">测试用户的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BF%86User-Recall"><span class="toc-number">7.0.1.</span> <span class="toc-text">用户记忆User Recall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95-Number-of-User"><span class="toc-number">7.0.2.</span> <span class="toc-text">需要多少用户进行测试 Number of User</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">数据采集方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%A3%B0%E6%80%9D%E8%80%83-thinking-aloud"><span class="toc-number">7.1.1.</span> <span class="toc-text">发声思考 thinking-aloud</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E7%94%A8%E6%88%B7%E6%B5%8B%E8%AF%95Remote-User-Testing"><span class="toc-number">7.1.2.</span> <span class="toc-text">远程用户测试Remote User Testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BB%8A%E6%B5%8B%E8%AF%95%E6%88%96%E9%95%BF%E5%BB%8A%E6%8B%A6%E6%88%AA%E6%B5%8B%E8%AF%95Hallway-testing"><span class="toc-number">7.1.3.</span> <span class="toc-text">长廊测试或长廊拦截测试Hallway testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%BC%E7%90%83%E8%BF%BD%E8%B8%AAeye-tracking"><span class="toc-number">7.1.4.</span> <span class="toc-text">眼球追踪eye tracking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7Usability-Questionnair"><span class="toc-number">7.1.5.</span> <span class="toc-text">可用性调查问卷Usability Questionnair</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Debugging-Induction-Deduction-Backtracking-Testing"><span class="toc-number">8.</span> <span class="toc-text">Debugging (Induction; Deduction; Backtracking;Testing)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E6%B3%95%E8%B0%83%E8%AF%95Induction"><span class="toc-number">8.1.</span> <span class="toc-text">归纳法调试Induction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E7%BB%8E%E6%B3%95Deduction"><span class="toc-number">8.2.</span> <span class="toc-text">演绎法Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%B0%83%E8%AF%95Backtracking"><span class="toc-number">8.3.</span> <span class="toc-text">回溯法调试Backtracking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%B3%95%E8%B0%83%E8%AF%95Testing"><span class="toc-number">8.4.</span> <span class="toc-text">测试法调试Testing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Agile-Extreme-Programming"><span class="toc-number">9.</span> <span class="toc-text">Agile &amp; Extreme Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91-Agile"><span class="toc-number">9.1.</span> <span class="toc-text">敏捷开发 Agile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%95"><span class="toc-number">9.1.1.</span> <span class="toc-text">敏捷测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B"><span class="toc-number">9.2.</span> <span class="toc-text">极限编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Three-tier-model"><span class="toc-number">10.</span> <span class="toc-text">Three-tier model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">10.0.1.</span> <span class="toc-text">三层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">10.0.2.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82%E6%B5%8B%E8%AF%95"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">表示层测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%B1%82%E6%B5%8B%E8%AF%95"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">业务层测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%82%E6%B5%8B%E8%AF%95"><span class="toc-number">10.0.2.3.</span> <span class="toc-text">数据层测试</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" title="软件测试">软件测试</a><time datetime="2024-01-11T08:06:09.000Z" title="发表于 2024-01-11 16:06:09">2024-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/" title="计算机网络-自顶向下">计算机网络-自顶向下</a><time datetime="2024-01-03T09:07:48.000Z" title="发表于 2024-01-03 17:07:48">2024-01-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/13/django/" title="django">django</a><time datetime="2023-12-13T10:45:28.000Z" title="发表于 2023-12-13 18:45:28">2023-12-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Weeb-killer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>